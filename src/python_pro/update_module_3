#%%
import yfinance as yf
import pandas as pd 
from sec_cik_mapper import StockMapper
from dataclasses import dataclass
from datetime import datetime, timedelta
import logging 
from scipy.optimize import minimize
import numpy as np

# Setup logging
logging.basicConfig(level=logging.INFO)

#---------------------------------------------------------
# Functions
#---------------------------------------------------------

def get_user_tickers():
    """
    Prompt the user to enter a list of stock tickers manually.

    Returns:
        list: A list of stock tickers entered by the user.
    """
    print("Enter the stock tickers you want to include in your portfolio.")
    print("Separate each ticker with a comma (e.g., AAPL, MSFT, GOOGL).")
    user_input = input("Tickers: ")
    
    # Process the input to create a list of tickers
    tickers = [ticker.strip().upper() for ticker in user_input.split(",") if ticker.strip()]
    
    if not tickers:
        print("No tickers entered. Please try again.")
        return get_user_tickers()  # Recurse if input is invalid

    print(f"You entered the following tickers: {tickers}")
    return tickers

# Function that retrieves historical data on prices for a given stock
def get_stock_data(ticker, start_date, end_date):
    """Retrieve historical data on prices for a given stock"""
    stock = yf.Ticker(ticker)
    data = stock.history(start=start_date, end=end_date, auto_adjust=False, actions=False)
    df = pd.DataFrame(data)
    df['ticker'] = ticker
    df.reset_index(inplace=True)
    return df

def get_stocks_data(tickers, start_date, end_date):
    """Retrieve historical data on prices for a list of stocks"""
    dfs = []
    for ticker in tickers:
        try:
            df = get_stock_data(ticker, start_date, end_date)
            if not df.empty:
                dfs.append(df)
        except:
            logging.warning(f"Stock {ticker} not found")
    data = pd.concat(dfs)
    return data

#---------------------------------------------------------
# Classes 
#---------------------------------------------------------

# Class that represents the data used in the backtest
@dataclass
class DataModule:
    data: pd.DataFrame

# Interface for the information set 
@dataclass
class Information:
    s: timedelta = timedelta(days=360)
    data_module: DataModule = None
    time_column: str = 'Date'
    company_column: str = 'ticker'
    adj_close_column: str = 'Close'

    def slice_data(self, t: datetime):
        data = self.data_module.data
        s = self.s
        data[self.time_column] = pd.to_datetime(data[self.time_column]).dt.tz_localize(None)
        data = data[(data[self.time_column] >= t - s) & (data[self.time_column] < t)]
        return data

    def get_prices(self, t: datetime):
        data = self.slice_data(t)
        prices = data.groupby(self.company_column)[self.adj_close_column].last()
        prices = prices.to_dict()
        return prices

    def compute_information(self, t: datetime):
        pass

    def compute_portfolio(self, t: datetime, information_set: dict):
        pass

@dataclass
class FirstTwoMoments(Information):
    def compute_portfolio(self, t: datetime, information_set):
        try:
            mu = information_set['expected_return']
            Sigma = information_set['covariance_matrix']
            gamma = 1
            n = len(mu)

            # Objective function
            obj = lambda x: -x.dot(mu) + gamma / 2 * x.dot(Sigma).dot(x)

            # Constraints (sum of weights = 1)
            cons = [{'type': 'eq', 'fun': lambda x: np.sum(x) - 1}]

            # Bounds (allow only positive weights)
            bounds = [(0.0, 1.0)] * n
            x0 = np.ones(n) / n

            # Minimize
            res = minimize(obj, x0, constraints=cons, bounds=bounds)

            portfolio = {k: None for k in information_set['companies']}

            if res.success:
                for i, company in enumerate(information_set['companies']):
                    portfolio[company] = res.x[i]
            else:
                raise Exception("Optimization did not converge")

            return portfolio
        except Exception as e:
            logging.warning("Error computing portfolio, returning equal weight portfolio")
            logging.warning(e)
            return {k: 1 / len(information_set['companies']) for k in information_set['companies']}

    def compute_information(self, t: datetime):
        data = self.slice_data(t)
        information_set = {}

        data = data.sort_values(by=[self.company_column, self.time_column])
        data['return'] = data.groupby(self.company_column)[self.adj_close_column].pct_change()
        
        information_set['expected_return'] = data.groupby(self.company_column)['return'].mean().to_numpy()
        data = data.pivot(index=self.time_column, columns=self.company_column, values=self.adj_close_column)
        data = data.dropna(axis=0)
        covariance_matrix = data.cov().to_numpy()
        information_set['covariance_matrix'] = covariance_matrix
        information_set['companies'] = data.columns.to_numpy()
        return information_set

#---------------------------------------------------------
# Example Usage
#---------------------------------------------------------

# Get tickers from the user
tickers = get_user_tickers()

# Retrieve historical data for user-entered tickers
start_date = '2020-01-01'
end_date = '2021-01-01'
df = get_stocks_data(tickers, start_date, end_date)

# Initialize DataModule and Information
data_module = DataModule(data=df)
info = FirstTwoMoments(s=timedelta(days=360), data_module=data_module)

# Compute information and portfolio for a given date
t = datetime(2020, 12, 31)
information_set = info.compute_information(t)

# Compute and display the optimized portfolio
portfolio = info.compute_portfolio(t, information_set)
print("Optimized Portfolio:", portfolio)
